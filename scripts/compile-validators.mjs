/**
 * Build script to pre-compile JSON Schema validators for CSP compliance.
 * Run with: node scripts/compile-validators.mjs
 * 
 * This script reads all schema YAML files from @netcracker/qip-schemas
 * and generates standalone validator code that doesn't use eval/new Function.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import standaloneCode from 'ajv/dist/standalone/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const SCHEMAS_DIR = path.join(rootDir, 'node_modules/@netcracker/qip-schemas/assets');
const OUTPUT_FILE = path.join(rootDir, 'src/validators/precompiled-validators.js');

// AJV configuration matching @rjsf/validator-ajv8 defaults
const AJV_CONFIG = {
  allErrors: true,
  multipleOfPrecision: 8,
  strict: false,
  verbose: true,
  discriminator: false,
  code: { lines: true, source: true, esm: true },
};

const COLOR_FORMAT_REGEX = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/;
const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;

async function main() {
  console.log('ðŸ”§ Compiling schema validators for CSP compliance...\n');

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Read all schema files
  const schemaFiles = fs.readdirSync(SCHEMAS_DIR)
    .filter(f => f.endsWith('.schema.yaml'));

  console.log(`ðŸ“ Found ${schemaFiles.length} schema files\n`);

  // Create AJV instance
  const ajv = new Ajv(AJV_CONFIG);
  addFormats(ajv);
  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);
  ajv.addFormat('color', COLOR_FORMAT_REGEX);
  // Add RJSF keywords
  ajv.addKeyword('__rjsf_additionalProperties');
  ajv.addKeyword('__additional_property');

  const schemas = {};
  const schemaMap = {};

  // Load and parse all schemas
  for (const file of schemaFiles) {
    const elementType = file.replace('.schema.yaml', '');
    const filePath = path.join(SCHEMAS_DIR, file);
    const yamlContent = fs.readFileSync(filePath, 'utf-8');
    
    try {
      const schema = yaml.load(yamlContent);
      const schemaId = schema.$id || `urn:schema:${elementType}`;
      
      schemas[elementType] = schema;
      schemaMap[schemaId] = elementType;
      
      // Add schema to AJV
      ajv.addSchema(schema, schemaId);
      console.log(`  âœ“ Loaded: ${elementType}`);
    } catch (err) {
      console.error(`  âœ— Error loading ${file}:`, err.message);
    }
  }

  console.log('\nðŸ”¨ Generating standalone validator code...\n');

  // Generate standalone code for all schemas
  try {
    // Create export mapping with sanitized names (no hyphens - valid JS identifiers)
    const exportMap = {};
    const nameMapping = {}; // Maps sanitized name back to original element type
    for (const [elementType, schema] of Object.entries(schemas)) {
      const schemaId = schema.$id || `urn:schema:${elementType}`;
      const safeName = sanitizeName(elementType);
      exportMap[safeName] = schemaId;
      nameMapping[safeName] = elementType;
    }

    let code = standaloneCode(ajv, exportMap);
    
    // Convert CommonJS require() calls to ES module imports
    // AJV standalone code may include runtime dependencies like ajv/dist/runtime/equal
    code = convertRequiresToImports(code);
    
    // Write the generated code
    fs.writeFileSync(OUTPUT_FILE, code);
    console.log(`âœ… Generated: ${OUTPUT_FILE}`);
    
    // Also generate a TypeScript definitions file
    const dtsContent = generateTypeDefs(Object.keys(schemas));
    fs.writeFileSync(OUTPUT_FILE.replace('.js', '.d.ts'), dtsContent);
    console.log(`âœ… Generated: ${OUTPUT_FILE.replace('.js', '.d.ts')}`);
    
    // Generate the schema map file with schemas and name mappings
    const schemaMapContent = generateSchemaMap(schemas, nameMapping);
    fs.writeFileSync(path.join(outputDir, 'schema-map.ts'), schemaMapContent);
    console.log(`âœ… Generated: ${path.join(outputDir, 'schema-map.ts')}`);

  } catch (err) {
    console.error('âŒ Error generating standalone code:', err);
    process.exit(1);
  }

  console.log('\nðŸŽ‰ Done! Validators compiled successfully.');
}

function generateTypeDefs(elementTypes) {
  return `// Auto-generated by scripts/compile-validators.mjs
// Do not edit manually

import type { ValidateFunction } from 'ajv';

${elementTypes.map(t => `export declare const ${sanitizeName(t)}: ValidateFunction;`).join('\n')}

export declare const validators: Record<string, ValidateFunction>;
`;
}

function generateSchemaMap(schemas, nameMapping) {
  // Generate mapping from element type (with hyphens) to sanitized name (camelCase)
  const mappingEntries = Object.entries(nameMapping)
    .map(([safeName, elementType]) => `  '${elementType}': '${safeName}'`)
    .join(',\n');

  return `// Auto-generated by scripts/compile-validators.mjs
// Do not edit manually

/**
 * Maps element types (e.g., 'http-trigger') to sanitized validator names (e.g., 'httpTrigger')
 * Use this to get the correct validator function from precompiled-validators.js
 */
export const elementTypeToValidatorName: Record<string, string> = {
${mappingEntries}
};
`;
}

/**
 * Convert CommonJS require() calls to ES module imports.
 * AJV standalone code may include runtime dependencies that use require().
 */
function convertRequiresToImports(code) {
  // Track all require statements and their variable names
  const requireRegex = /const\s+(\w+)\s*=\s*require\(["']([^"']+)["']\)(\.default)?;?/g;
  const imports = [];
  
  // Find all require statements
  let match;
  while ((match = requireRegex.exec(code)) !== null) {
    const [fullMatch, varName, modulePath, hasDefault] = match;
    imports.push({
      fullMatch,
      varName,
      modulePath,
      hasDefault: !!hasDefault
    });
  }
  
  if (imports.length === 0) {
    return code;
  }
  
  // Generate import statements
  const importStatements = imports.map(({ varName, modulePath, hasDefault }) => {
    if (hasDefault) {
      return `import ${varName} from "${modulePath}";`;
    } else {
      return `import * as ${varName} from "${modulePath}";`;
    }
  }).join('\n');
  
  // Remove require statements from code
  let processedCode = code;
  for (const { fullMatch } of imports) {
    processedCode = processedCode.replace(fullMatch, '');
  }
  
  // Remove "use strict" if present (not needed in ESM)
  processedCode = processedCode.replace(/^"use strict";\s*/m, '');
  
  // Add imports at the top
  return importStatements + '\n\n' + processedCode;
}

// JavaScript reserved keywords that can't be used as identifiers
const RESERVED_KEYWORDS = new Set([
  'break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do',
  'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return',
  'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with',
  'class', 'const', 'enum', 'export', 'extends', 'import', 'super',
  'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'
]);

function sanitizeName(name) {
  // Convert element-type-name to elementTypeName for valid JS identifier
  let result = name.replace(/-(\w)/g, (_, c) => c.toUpperCase()).replace(/-/g, '');
  
  // Handle reserved keywords by adding a suffix
  if (RESERVED_KEYWORDS.has(result)) {
    result = result + 'Element';
  }
  
  return result;
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
