/**
 * CSP-compliant validator for @rjsf forms.
 * Uses precompiled AJV validators that don't use eval/new Function.
 * 
 * This validator is generated by scripts/compile-validators.mjs
 */

import type { ValidatorType, ValidationData, CustomValidator, ErrorTransformer, UiSchema, RJSFSchema, FormContextType, ErrorSchema } from '@rjsf/utils';
import { createErrorHandler, toErrorSchema, unwrapErrorHandler, validationDataMerge } from '@rjsf/utils';
import type { ErrorObject, ValidateFunction } from 'ajv';
import { elementTypeToValidatorName } from './schema-map';
import * as validators from './precompiled-validators';

// Type for the validators module (use unknown first per TS recommendation)
const validatorFunctions = validators as unknown as Record<string, ValidateFunction>;

/**
 * Get the precompiled validator function for a given element type
 */
function getValidatorForElementType(elementType: string): ValidateFunction | undefined {
  const validatorName = elementTypeToValidatorName[elementType];
  if (!validatorName) {
    console.warn(`No precompiled validator found for element type: ${elementType}`);
    return undefined;
  }
  return validatorFunctions[validatorName];
}

/**
 * Transform AJV errors to RJSF format
 */
function transformAJVErrors<T>(errors: ErrorObject[] | null | undefined): ValidationData<T> {
  if (!errors || errors.length === 0) {
    return { errors: [], errorSchema: {} as ErrorSchema<T> };
  }

  const rjsfErrors = errors.map((error) => {
    const { instancePath, keyword, params, message = '' } = error;
    const property = instancePath.replace(/\//g, '.');
    
    return {
      name: keyword,
      property,
      message,
      params,
      stack: `${property} ${message}`.trim(),
      schemaPath: error.schemaPath,
    };
  });

  return {
    errors: rjsfErrors,
    errorSchema: toErrorSchema(rjsfErrors) as ErrorSchema<T>,
  };
}

/**
 * Creates a CSP-compliant validator for the given element type.
 * 
 * @param elementType - The element type (e.g., 'http-trigger', 'service-call')
 * @returns A ValidatorType implementation that uses precompiled validators
 */
export function createCSPCompliantValidator<
  T = any,
  S extends RJSFSchema = RJSFSchema,
  F extends FormContextType = any
>(elementType: string): ValidatorType<T, S, F> {
  const validateFn = getValidatorForElementType(elementType);
  
  return {
    validateFormData(
      formData: T | undefined,
      _schema: S,
      customValidate?: CustomValidator<T, S, F>,
      transformErrors?: ErrorTransformer<T, S, F>,
      uiSchema?: UiSchema<T, S, F>
    ): ValidationData<T> {
      let validationData: ValidationData<T>;
      
      if (validateFn) {
        // Use precompiled validator
        validateFn(formData);
        validationData = transformAJVErrors<T>(validateFn.errors);
        // Clear errors for next validation
        validateFn.errors = null;
      } else {
        // Fallback: no validation (validator not found)
        validationData = { errors: [], errorSchema: {} as ErrorSchema<T> };
      }
      
      // Apply transformErrors if provided
      if (transformErrors && validationData.errors.length > 0) {
        validationData.errors = transformErrors(validationData.errors, uiSchema);
        validationData.errorSchema = toErrorSchema(validationData.errors) as ErrorSchema<T>;
      }
      
      // Apply custom validation if provided
      if (customValidate) {
        const errorHandler = createErrorHandler<T>(formData as T);
        const userErrorHandler = customValidate(formData as T, errorHandler, uiSchema);
        const userErrors = unwrapErrorHandler<T>(userErrorHandler);
        validationData = validationDataMerge(validationData, userErrors);
      }
      
      return validationData;
    },

    isValid(_schema: S, formData: T | undefined, _rootSchema: S): boolean {
      if (!validateFn) {
        // If no validator, assume valid
        return true;
      }
      const result = validateFn(formData);
      // Clear errors for next validation
      validateFn.errors = null;
      return result as boolean;
    },

    rawValidation<Result = any>(_schema: S, formData?: T): { errors?: Result[]; validationError?: Error } {
      if (!validateFn) {
        return { errors: undefined };
      }
      
      try {
        validateFn(formData);
        const errors = validateFn.errors || undefined;
        // Clear errors for next validation
        validateFn.errors = null;
        return { errors: errors as unknown as Result[] };
      } catch (err) {
        return { validationError: err as Error };
      }
    },
  };
}

/**
 * A fallback validator that doesn't validate anything.
 * Use this when CSP compliance is required but precompiled validators aren't available.
 */
export const noOpValidator: ValidatorType = {
  validateFormData() {
    return { errors: [], errorSchema: {} };
  },
  isValid() {
    return true;
  },
  rawValidation() {
    return { errors: undefined };
  },
};

export default createCSPCompliantValidator;
